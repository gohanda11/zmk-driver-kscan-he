/*
 * SPDX-License-Identifier: MIT
 *
 * ZMK kscan driver for Hall Effect keyboards using SN74LV4051A analog
 * multiplexers and GH39FKSW Hall Effect sensors on XIAO nRF52840.
 *
 * Hardware:
 *   - MCU:    Seeed XIAO nRF52840 (nRF52840, SAADC 12-bit)
 *   - Sensor: GH39FKSW x22
 *   - MUX:    SN74LV4051A x3  (8:1 analog mux, shared select lines)
 *   - ADC:    AIN1(P0.03), AIN4(P0.28), AIN5(P0.29)
 *   - SEL:    P1.13(S0), P1.14(S1), P1.15(S2)
 */

#define DT_DRV_COMPAT zmk_kscan_adc_mux

#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/kscan.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/adc.h>
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include "he_key_state.h"

LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);

/* -----------------------------------------------------------------------
 * Distance LUT: maps normalized ADC position (0..255) → distance (0..255)
 *
 * This is a linear identity LUT for initial bring-up.
 * Replace with a logarithmic LUT generated by libhmk/tools/distance_lut.py
 * once real GH39FKSW sensor curves are measured.
 * ----------------------------------------------------------------------- */
static const uint8_t distance_lut[DISTANCE_LUT_SIZE] = {
      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
     96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
    112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
    128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
    160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
    176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
    192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
    208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
    224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
    240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,
};

/* -----------------------------------------------------------------------
 * Macros
 * ----------------------------------------------------------------------- */

/* EMA filter: y = (x + y*(N-1)) / N  where N = 2^EMA_ALPHA_EXP */
#define EMA(new_val, old_val) \
    ((uint16_t)(((uint32_t)(new_val) + \
                 (uint32_t)(old_val) * ((1u << EMA_ALPHA_EXP) - 1u)) \
                >> EMA_ALPHA_EXP))

/* Devicetree instance helpers */
#define INST_NUM_SELECT(n)  DT_INST_PROP_LEN(n, select_gpios)
#define INST_NUM_ADC(n)     DT_INST_PROP_LEN(n, io_channels)
#define INST_NUM_ADDR(n)    (1u << INST_NUM_SELECT(n))
#define INST_NUM_KEYS(n)    DT_INST_PROP(n, num_keys)

/* -----------------------------------------------------------------------
 * Shared helper functions (not per-instance)
 * ----------------------------------------------------------------------- */

/**
 * Convert ADC value to travel distance (0-255) using LUT.
 */
static inline uint8_t adc_to_distance(uint16_t adc,
                                       uint16_t rest,
                                       uint16_t bottom)
{
    if (adc <= rest || rest >= bottom) {
        return 0;
    }
    if (adc >= bottom) {
        return 255;
    }
    uint32_t normalized = (uint32_t)(adc - rest) * (DISTANCE_LUT_SIZE - 1u)
                          / (uint32_t)(bottom - rest);
    return distance_lut[normalized];
}

/**
 * Drive MUX select lines S0-S2 to the given address (0-7).
 * Bit 0 → S0, Bit 1 → S1, Bit 2 → S2.
 */
static void set_mux_address(const struct gpio_dt_spec *sel,
                             uint8_t num_sel,
                             uint8_t addr)
{
    for (uint8_t i = 0; i < num_sel; i++) {
        gpio_pin_set_dt(&sel[i], (addr >> i) & 1u);
    }
}

/* -----------------------------------------------------------------------
 * Per-instance macro expansion
 * ----------------------------------------------------------------------- */

#define GPIO_SPEC_ENTRY(node, prop, idx)    GPIO_DT_SPEC_GET_BY_IDX(node, prop, idx),
#define ADC_DT_SPEC_ENTRY(node, prop, idx)  ADC_DT_SPEC_GET_BY_IDX(node, idx),

#define KSCAN_ADC_MUX_INST(n)                                                   \
                                                                                \
    /* Static GPIO specs for select lines */                                    \
    static const struct gpio_dt_spec he_select_gpios_##n[] = {                  \
        DT_INST_FOREACH_PROP_ELEM(n, select_gpios, GPIO_SPEC_ENTRY)             \
    };                                                                          \
                                                                                \
    /* Static ADC channel specs */                                              \
    static const struct adc_dt_spec he_adc_channels_##n[] = {                   \
        DT_INST_FOREACH_PROP_ELEM(n, io_channels, ADC_DT_SPEC_ENTRY)            \
    };                                                                          \
                                                                                \
    /* MUX map: flat array [addr*num_adc + adc_idx] → key_index */             \
    static const uint8_t he_mux_map_##n[] = DT_INST_PROP(n, mux_map);          \
                                                                                \
    /* Driver configuration (read-only, from devicetree) */                    \
    struct he_kscan_cfg_##n {                                                   \
        const struct gpio_dt_spec *select_gpios;                                \
        const struct adc_dt_spec  *adc_channels;                               \
        const uint8_t             *mux_map;                                     \
        uint8_t  num_select;                                                    \
        uint8_t  num_adc;                                                       \
        uint8_t  num_addr;                                                      \
        uint8_t  num_keys;                                                      \
        uint16_t scan_period_ms;                                                \
        uint16_t settle_us;                                                     \
        bool     invert_adc;                                                    \
        uint8_t  press_threshold;                                               \
        uint8_t  release_threshold;                                             \
        uint16_t calibration_duration_ms;                                       \
    };                                                                          \
                                                                                \
    static const struct he_kscan_cfg_##n he_cfg_##n = {                         \
        .select_gpios          = he_select_gpios_##n,                           \
        .adc_channels          = he_adc_channels_##n,                          \
        .mux_map               = he_mux_map_##n,                                \
        .num_select            = INST_NUM_SELECT(n),                            \
        .num_adc               = INST_NUM_ADC(n),                               \
        .num_addr              = INST_NUM_ADDR(n),                              \
        .num_keys              = INST_NUM_KEYS(n),                              \
        .scan_period_ms        = DT_INST_PROP(n, scan_period_ms),               \
        .settle_us             = DT_INST_PROP(n, settle_us),                    \
        .invert_adc            = DT_INST_PROP(n, invert_adc),                   \
        .press_threshold       = DT_INST_PROP(n, press_threshold),              \
        .release_threshold     = DT_INST_PROP(n, release_threshold),            \
        .calibration_duration_ms = DT_INST_PROP(n, calibration_duration_ms),    \
    };                                                                          \
                                                                                \
    /* Driver runtime data */                                                   \
    struct he_kscan_data_##n {                                                  \
        const struct device *dev;                                               \
        kscan_callback_t     callback;                                          \
        struct k_work_delayable scan_work;                                      \
        struct he_key_state  keys[INST_NUM_KEYS(n)];                            \
        int16_t              adc_buf[INST_NUM_ADC(n)];                          \
    };                                                                          \
                                                                                \
    static struct he_kscan_data_##n he_data_##n;

/* -----------------------------------------------------------------------
 * Per-instance scan / calibration / API functions
 * ----------------------------------------------------------------------- */

#define KSCAN_ADC_MUX_FUNCS(n)                                                  \
                                                                                \
    /* --------------------------------------------------------------- */       \
    /* Scan work handler: runs once per scan_period_ms                  */       \
    /* --------------------------------------------------------------- */       \
    static void he_scan_##n(struct k_work *work)                                \
    {                                                                           \
        struct k_work_delayable *dwork = k_work_delayable_from_work(work);      \
        struct he_kscan_data_##n *data =                                        \
            CONTAINER_OF(dwork, struct he_kscan_data_##n, scan_work);           \
        const struct he_kscan_cfg_##n *cfg = &he_cfg_##n;                       \
        struct adc_sequence seq = { 0 };                                        \
                                                                                \
        for (uint8_t addr = 0; addr < cfg->num_addr; addr++) {                  \
            /* 1. Drive MUX address */                                          \
            set_mux_address(cfg->select_gpios, cfg->num_select, addr);          \
                                                                                \
            /* 2. Wait for MUX output to settle */                              \
            k_busy_wait(cfg->settle_us);                                        \
                                                                                \
            /* 3. Read each ADC channel */                                      \
            for (uint8_t ai = 0; ai < cfg->num_adc; ai++) {                     \
                                                                                \
                /* Map slot → key index; skip unused slots */                   \
                uint8_t key_idx = cfg->mux_map[addr * cfg->num_adc + ai];       \
                if (key_idx >= cfg->num_keys) {                                 \
                    continue;                                                   \
                }                                                               \
                                                                                \
                /* ADC read */                                                  \
                (void)adc_sequence_init_dt(&cfg->adc_channels[ai], &seq);       \
                seq.buffer      = &data->adc_buf[ai];                           \
                seq.buffer_size = sizeof(int16_t);                              \
                                                                                \
                if (adc_read_dt(&cfg->adc_channels[ai], &seq) < 0) {           \
                    LOG_ERR("ADC read fail addr=%d ch=%d", addr, ai);           \
                    continue;                                                   \
                }                                                               \
                                                                                \
                /* 4. Apply polarity correction */                              \
                int16_t raw = data->adc_buf[ai];                                \
                if (raw < 0) { raw = 0; }                                       \
                uint16_t adc_val = (uint16_t)raw;                               \
                if (cfg->invert_adc) {                                          \
                    adc_val = ADC_MAX_VALUE - adc_val;                          \
                }                                                               \
                                                                                \
                /* 5. EMA filter */                                             \
                struct he_key_state *ks = &data->keys[key_idx];                 \
                ks->adc_filtered = EMA(adc_val, ks->adc_filtered);              \
                                                                                \
                /* 6. Track bottom-out (max travel) */                          \
                if (ks->adc_filtered >=                                         \
                    (uint16_t)(ks->adc_bottom + CALIBRATION_EPSILON)) {         \
                    ks->adc_bottom = ks->adc_filtered;                          \
                }                                                               \
                                                                                \
                /* 7. Distance conversion via LUT */                            \
                ks->distance = adc_to_distance(ks->adc_filtered,               \
                                               ks->adc_rest,                    \
                                               ks->adc_bottom);                 \
                                                                                \
                /* 8. Threshold + hysteresis press/release detection */         \
                bool was_pressed = ks->pressed;                                 \
                if (!ks->pressed &&                                             \
                    ks->distance >= cfg->press_threshold) {                     \
                    ks->pressed = true;                                         \
                } else if (ks->pressed &&                                       \
                           ks->distance <= cfg->release_threshold) {            \
                    ks->pressed = false;                                        \
                }                                                               \
                                                                                \
                /* 9. Fire callback on state change */                          \
                if (ks->pressed != was_pressed && data->callback) {             \
                    LOG_DBG("key %d %s dist=%d",                               \
                            key_idx,                                            \
                            ks->pressed ? "press" : "release",                 \
                            ks->distance);                                      \
                    data->callback(data->dev, 0, key_idx, ks->pressed);         \
                }                                                               \
            }                                                                   \
        }                                                                       \
                                                                                \
        /* Schedule next scan */                                                \
        k_work_reschedule(&data->scan_work,                                     \
                          K_MSEC(cfg->scan_period_ms));                         \
    }                                                                           \
                                                                                \
    /* --------------------------------------------------------------- */       \
    /* Calibration: collect rest values for calibration_duration_ms     */       \
    /* Keys must be fully released during this period.                   */      \
    /* --------------------------------------------------------------- */       \
    static void he_calibrate_##n(const struct device *dev)                      \
    {                                                                           \
        struct he_kscan_data_##n *data = dev->data;                             \
        const struct he_kscan_cfg_##n *cfg = dev->config;                       \
        struct adc_sequence seq = { 0 };                                        \
                                                                                \
        /* Seed all keys with a safe initial rest value.                */      \
        /* invert_adc=true → rest is at low ADC (key not pressed)       */      \
        /* We start at ADC_MAX_VALUE/2 and converge downward.           */      \
        const uint16_t init_rest   = ADC_MAX_VALUE / 2u;                        \
        const uint16_t init_bottom = init_rest + 650u;                          \
                                                                                \
        for (uint8_t k = 0; k < cfg->num_keys; k++) {                          \
            data->keys[k].adc_filtered = init_rest;                             \
            data->keys[k].adc_rest     = init_rest;                             \
            data->keys[k].adc_bottom   = (init_bottom > ADC_MAX_VALUE)          \
                                         ? ADC_MAX_VALUE : init_bottom;         \
            data->keys[k].distance     = 0;                                     \
            data->keys[k].pressed      = false;                                 \
        }                                                                       \
                                                                                \
        const int64_t deadline = k_uptime_get() +                               \
                                 (int64_t)cfg->calibration_duration_ms;         \
                                                                                \
        while (k_uptime_get() < deadline) {                                     \
            for (uint8_t addr = 0; addr < cfg->num_addr; addr++) {              \
                set_mux_address(cfg->select_gpios, cfg->num_select, addr);      \
                k_busy_wait(cfg->settle_us);                                    \
                                                                                \
                for (uint8_t ai = 0; ai < cfg->num_adc; ai++) {                 \
                    uint8_t key_idx = cfg->mux_map[addr * cfg->num_adc + ai];   \
                    if (key_idx >= cfg->num_keys) { continue; }                 \
                                                                                \
                    (void)adc_sequence_init_dt(&cfg->adc_channels[ai], &seq);   \
                    seq.buffer      = &data->adc_buf[ai];                       \
                    seq.buffer_size = sizeof(int16_t);                          \
                                                                                \
                    if (adc_read_dt(&cfg->adc_channels[ai], &seq) < 0) {        \
                        continue;                                               \
                    }                                                           \
                                                                                \
                    int16_t raw = data->adc_buf[ai];                            \
                    if (raw < 0) { raw = 0; }                                   \
                    uint16_t adc_val = (uint16_t)raw;                           \
                    if (cfg->invert_adc) {                                      \
                        adc_val = ADC_MAX_VALUE - adc_val;                      \
                    }                                                           \
                                                                                \
                    struct he_key_state *ks = &data->keys[key_idx];             \
                    ks->adc_filtered = EMA(adc_val, ks->adc_filtered);          \
                                                                                \
                    /* Drive rest downward: converge to stable minimum */       \
                    if (ks->adc_filtered + CALIBRATION_EPSILON <=               \
                        ks->adc_rest) {                                         \
                        ks->adc_rest = ks->adc_filtered;                        \
                    }                                                           \
                                                                                \
                    /* Ensure bottom stays above rest by at least 650 */        \
                    uint16_t min_bottom = ks->adc_rest + 650u;                  \
                    if (min_bottom > ADC_MAX_VALUE) {                           \
                        min_bottom = ADC_MAX_VALUE;                             \
                    }                                                           \
                    if (ks->adc_bottom < min_bottom) {                          \
                        ks->adc_bottom = min_bottom;                            \
                    }                                                           \
                }                                                               \
            }                                                                   \
        }                                                                       \
                                                                                \
        LOG_INF("HE20 calibration done."                                        \
                " key[0] rest=%u bottom=%u"                                     \
                " key[21] rest=%u bottom=%u",                                   \
                data->keys[0].adc_rest,  data->keys[0].adc_bottom,             \
                data->keys[21].adc_rest, data->keys[21].adc_bottom);            \
    }                                                                           \
                                                                                \
    /* --------------------------------------------------------------- */       \
    /* kscan API: configure (set callback)                              */       \
    /* --------------------------------------------------------------- */       \
    static int he_kscan_configure_##n(const struct device *dev,                 \
                                      kscan_callback_t callback)                \
    {                                                                           \
        struct he_kscan_data_##n *data = dev->data;                             \
        if (!callback) { return -EINVAL; }                                      \
        data->callback = callback;                                              \
        return 0;                                                               \
    }                                                                           \
                                                                                \
    /* --------------------------------------------------------------- */       \
    /* kscan API: enable (start scan loop)                              */       \
    /* --------------------------------------------------------------- */       \
    static int he_kscan_enable_##n(const struct device *dev)                    \
    {                                                                           \
        struct he_kscan_data_##n *data = dev->data;                             \
        const struct he_kscan_cfg_##n *cfg = dev->config;                       \
        k_work_reschedule(&data->scan_work, K_MSEC(cfg->scan_period_ms));       \
        return 0;                                                               \
    }                                                                           \
                                                                                \
    /* --------------------------------------------------------------- */       \
    /* kscan API: disable (stop scan loop)                              */       \
    /* --------------------------------------------------------------- */       \
    static int he_kscan_disable_##n(const struct device *dev)                   \
    {                                                                           \
        struct he_kscan_data_##n *data = dev->data;                             \
        k_work_cancel_delayable(&data->scan_work);                              \
        return 0;                                                               \
    }                                                                           \
                                                                                \
    /* --------------------------------------------------------------- */       \
    /* Device init                                                      */       \
    /* --------------------------------------------------------------- */       \
    static int he_kscan_init_##n(const struct device *dev)                      \
    {                                                                           \
        struct he_kscan_data_##n *data = dev->data;                             \
        const struct he_kscan_cfg_##n *cfg = dev->config;                       \
        int ret;                                                                \
                                                                                \
        data->dev = dev;                                                        \
                                                                                \
        /* Configure MUX select GPIO pins as outputs, default LOW */            \
        for (uint8_t i = 0; i < cfg->num_select; i++) {                         \
            if (!device_is_ready(cfg->select_gpios[i].port)) {                  \
                LOG_ERR("Select GPIO %d port not ready", i);                    \
                return -ENODEV;                                                 \
            }                                                                   \
            ret = gpio_pin_configure_dt(&cfg->select_gpios[i],                  \
                                        GPIO_OUTPUT_LOW);                       \
            if (ret < 0) {                                                      \
                LOG_ERR("Select GPIO %d config failed: %d", i, ret);            \
                return ret;                                                     \
            }                                                                   \
        }                                                                       \
                                                                                \
        /* Set up ADC channels */                                               \
        for (uint8_t i = 0; i < cfg->num_adc; i++) {                            \
            if (!device_is_ready(cfg->adc_channels[i].dev)) {                   \
                LOG_ERR("ADC device for channel %d not ready", i);              \
                return -ENODEV;                                                 \
            }                                                                   \
            ret = adc_channel_setup_dt(&cfg->adc_channels[i]);                  \
            if (ret < 0) {                                                      \
                LOG_ERR("ADC channel %d setup failed: %d", i, ret);             \
                return ret;                                                     \
            }                                                                   \
        }                                                                       \
                                                                                \
        /* Initialize scan work item */                                         \
        k_work_init_delayable(&data->scan_work, he_scan_##n);                   \
                                                                                \
        /* Run initial calibration (blocking, ~500ms) */                        \
        he_calibrate_##n(dev);                                                  \
                                                                                \
        LOG_INF("HE20 kscan driver initialized (%d keys)", cfg->num_keys);      \
        return 0;                                                               \
    }                                                                           \
                                                                                \
    static const struct kscan_driver_api he_kscan_api_##n = {                   \
        .config           = he_kscan_configure_##n,                             \
        .enable_callback  = he_kscan_enable_##n,                                \
        .disable_callback = he_kscan_disable_##n,                               \
    };                                                                          \
                                                                                \
    DEVICE_DT_INST_DEFINE(n,                                                    \
                          he_kscan_init_##n,                                    \
                          NULL,                                                 \
                          &he_data_##n,                                         \
                          &he_cfg_##n,                                          \
                          POST_KERNEL,                                          \
                          CONFIG_KSCAN_INIT_PRIORITY,                           \
                          &he_kscan_api_##n);

/* -----------------------------------------------------------------------
 * Instantiate driver for every enabled DT node with compatible string
 * ----------------------------------------------------------------------- */

#define KSCAN_ADC_MUX_DEFINE(n) \
    KSCAN_ADC_MUX_INST(n)       \
    KSCAN_ADC_MUX_FUNCS(n)

DT_INST_FOREACH_STATUS_OKAY(KSCAN_ADC_MUX_DEFINE)
